# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rack/all/rack.rbi
#
# rack-1.6.13

module Rack
  def self.release; end
  def self.version; end
end
module Rack::Multipart
  def self.build_multipart(params, first = nil); end
  def self.parse_multipart(env); end
end
module Rack::Utils
  def best_q_match(q_value_header, available_mimes); end
  def build_nested_query(value, prefix = nil); end
  def build_query(params); end
  def byte_ranges(env, size); end
  def bytesize(string); end
  def clean_path_info(path_info); end
  def delete_cookie_header!(header, key, value = nil); end
  def escape(s); end
  def escape_html(string); end
  def escape_path(s); end
  def normalize_params(params, name, v = nil, depth = nil); end
  def params_hash_type?(obj); end
  def parse_nested_query(qs, d = nil); end
  def parse_query(qs, d = nil, &unescaper); end
  def q_values(q_value_header); end
  def rfc2109(time); end
  def rfc2822(time); end
  def secure_compare(a, b); end
  def select_best_encoding(available_encodings, accept_encoding); end
  def self.best_q_match(q_value_header, available_mimes); end
  def self.build_nested_query(value, prefix = nil); end
  def self.build_query(params); end
  def self.byte_ranges(env, size); end
  def self.bytesize(string); end
  def self.clean_path_info(path_info); end
  def self.delete_cookie_header!(header, key, value = nil); end
  def self.escape(s); end
  def self.escape_html(string); end
  def self.escape_path(s); end
  def self.key_space_limit; end
  def self.key_space_limit=(arg0); end
  def self.multipart_part_limit; end
  def self.multipart_part_limit=(arg0); end
  def self.normalize_params(params, name, v = nil, depth = nil); end
  def self.param_depth_limit; end
  def self.param_depth_limit=(arg0); end
  def self.params_hash_type?(obj); end
  def self.parse_nested_query(qs, d = nil); end
  def self.parse_query(qs, d = nil, &unescaper); end
  def self.q_values(q_value_header); end
  def self.rfc2109(time); end
  def self.rfc2822(time); end
  def self.secure_compare(a, b); end
  def self.select_best_encoding(available_encodings, accept_encoding); end
  def self.set_cookie_header!(header, key, value); end
  def self.status_code(status); end
  def self.unescape(s, encoding = nil); end
  def set_cookie_header!(header, key, value); end
  def status_code(status); end
  def unescape(s, encoding = nil); end
end
class Rack::Utils::ParameterTypeError < TypeError
end
class Rack::Utils::InvalidParameterError < ArgumentError
end
class Rack::Utils::Context
  def app; end
  def call(env); end
  def context(env, app = nil); end
  def for; end
  def initialize(app_f, app_r); end
  def recontext(app); end
end
class Rack::Utils::HeaderHash < Hash
  def [](k); end
  def []=(k, v); end
  def delete(k); end
  def each; end
  def has_key?(k); end
  def include?(k); end
  def initialize(hash = nil); end
  def key?(k); end
  def member?(k); end
  def merge!(other); end
  def merge(other); end
  def replace(other); end
  def self.new(hash = nil); end
  def to_hash; end
end
class Rack::Utils::KeySpaceConstrainedParams
  def [](key); end
  def []=(key, value); end
  def initialize(limit = nil); end
  def key?(key); end
  def to_params_hash; end
end
module Rack::Auth
end
module Rack::Auth::Digest
end
module Rack::Session
end
class Rack::BodyProxy
  def close; end
  def closed?; end
  def each(*args, &block); end
  def initialize(body, &block); end
  def method_missing(*args, &block); end
  def respond_to?(*args); end
end
class Rack::Cascade
  def <<(app); end
  def add(app); end
  def apps; end
  def call(env); end
  def include?(app); end
  def initialize(apps, catch = nil); end
end
class Rack::Chunked
  def call(env); end
  def chunkable_version?(ver); end
  def initialize(app); end
  include Rack::Utils
end
class Rack::Chunked::Body
  def close; end
  def each; end
  def initialize(body); end
  include Rack::Utils
end
class Rack::CommonLogger
  def call(env); end
  def extract_content_length(headers); end
  def initialize(app, logger = nil); end
  def log(env, status, header, began_at); end
end
class Rack::ConditionalGet
  def call(env); end
  def etag_matches?(none_match, headers); end
  def fresh?(env, headers); end
  def initialize(app); end
  def modified_since?(modified_since, headers); end
  def to_rfc2822(since); end
end
class Rack::Config
  def call(env); end
  def initialize(app, &block); end
end
class Rack::ContentLength
  def call(env); end
  def initialize(app); end
  include Rack::Utils
end
class Rack::ContentType
  def call(env); end
  def initialize(app, content_type = nil); end
  include Rack::Utils
end
class Rack::ETag
  def call(env); end
  def digest_body(body); end
  def etag_body?(body); end
  def etag_status?(status); end
  def initialize(app, no_cache_control = nil, cache_control = nil); end
  def skip_caching?(headers); end
end
class Rack::Request
  def GET; end
  def POST; end
  def [](key); end
  def []=(key, value); end
  def accept_encoding; end
  def accept_language; end
  def base_url; end
  def body; end
  def content_charset; end
  def content_length; end
  def content_type; end
  def cookies; end
  def delete?; end
  def delete_param(k); end
  def env; end
  def form_data?; end
  def forwarded_scheme; end
  def fullpath; end
  def get?; end
  def head?; end
  def host; end
  def host_with_port; end
  def initialize(env); end
  def ip; end
  def link?; end
  def logger; end
  def media_type; end
  def media_type_params; end
  def options?; end
  def params; end
  def parse_http_accept_header(header); end
  def parse_multipart(env); end
  def parse_query(qs); end
  def parseable_data?; end
  def patch?; end
  def path; end
  def path_info; end
  def path_info=(s); end
  def port; end
  def post?; end
  def put?; end
  def query_string; end
  def referer; end
  def referrer; end
  def reject_trusted_ip_addresses(ip_addresses); end
  def request_method; end
  def scheme; end
  def script_name; end
  def script_name=(s); end
  def session; end
  def session_options; end
  def split_ip_addresses(ip_addresses); end
  def ssl?; end
  def strip_doublequotes(s); end
  def trace?; end
  def trusted_proxy?(ip); end
  def unlink?; end
  def update_param(k, v); end
  def url; end
  def user_agent; end
  def values_at(*keys); end
  def xhr?; end
end
class Rack::ShowExceptions
  def accepts_html?(env); end
  def call(env); end
  def dump_exception(exception); end
  def h(obj); end
  def initialize(app); end
  def prefers_plaintext?(env); end
  def pretty(env, exception); end
end
class Rack::Response
  def [](key); end
  def []=(key, value); end
  def body; end
  def body=(arg0); end
  def close; end
  def delete_cookie(key, value = nil); end
  def each(&callback); end
  def empty?; end
  def finish(&block); end
  def header; end
  def headers; end
  def initialize(body = nil, status = nil, header = nil); end
  def length; end
  def length=(arg0); end
  def redirect(target, status = nil); end
  def set_cookie(key, value); end
  def status; end
  def status=(arg0); end
  def to_a(&block); end
  def to_ary(&block); end
  def write(str); end
  include Rack::Response::Helpers
end
module Rack::Response::Helpers
  def accepted?; end
  def bad_request?; end
  def client_error?; end
  def content_length; end
  def content_type; end
  def created?; end
  def forbidden?; end
  def headers; end
  def i_m_a_teapot?; end
  def include?(header); end
  def informational?; end
  def invalid?; end
  def location; end
  def method_not_allowed?; end
  def not_found?; end
  def ok?; end
  def original_headers; end
  def redirect?; end
  def redirection?; end
  def server_error?; end
  def successful?; end
  def unauthorized?; end
  def unprocessable?; end
end
